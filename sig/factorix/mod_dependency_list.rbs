# RBS type signature file
# NOTE: Do not include private method definitions in RBS files.
#       Only public interfaces should be documented here.

module Factorix
  # Represents a collection of MOD dependencies
  class MODDependencyList
    include Enumerable[MODDependency]

    @dependencies: Array[MODDependency]

    # Create MODDependencyList from an array of dependency strings
    def self.from_strings: (Array[String] dependency_strings) -> MODDependencyList

    # Initialize a MODDependencyList collection
    def initialize: (?Array[MODDependency] dependencies) -> void

    # Iterate through all dependencies
    def each: () { (MODDependency) -> void } -> MODDependencyList
            | () -> Enumerator[MODDependency, void]

    # Get all required dependencies
    def required: () -> Array[MODDependency]

    # Get all optional dependencies (including hidden optional)
    def optional: () -> Array[MODDependency]

    # Get all incompatible dependencies
    def incompatible: () -> Array[MODDependency]

    # Get all load-neutral dependencies
    def load_neutral: () -> Array[MODDependency]

    # Check if this collection depends on a specific MOD
    def depends_on?: (String | MOD mod_name_or_mod) -> bool

    # Check if this collection marks a MOD as incompatible
    def incompatible_with?: (String | MOD mod_name_or_mod) -> bool

    # Check if the collection is empty
    def empty?: () -> bool

    # Get the total number of dependencies
    def size: () -> Integer

    # Check if all required dependencies are satisfied
    def satisfied_by?: (Hash[String, Types::MODVersion] available_mods) -> bool

    # Get list of incompatible MODs that are present
    def conflicts_with?: (Hash[String, Types::MODVersion] available_mods) -> Array[String]

    # Get list of missing required dependencies
    def missing_required: (Hash[String, Types::MODVersion] available_mods) -> Array[String]

    # Get list of dependencies with unsatisfied version requirements
    def unsatisfied_versions: (Hash[String, Types::MODVersion] available_mods) -> Hash[String, Hash[Symbol, String]]

    # Detect circular dependencies in a collection of MOD dependencies
    def self.detect_circular: (Hash[String, MODDependencyList] mod_dependencies_map) -> Array[Array[String]]

    # Convert to array of dependency strings
    def to_a: () -> Array[String]

    # Convert to hash keyed by MOD name
    def to_h: () -> Hash[String, MODDependency]
  end
end
