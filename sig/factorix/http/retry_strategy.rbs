# frozen_string_literal: true

# RBS type signature file
# NOTE: Do not include private method definitions in RBS files.
#       Only public interfaces should be documented here.

module Factorix
  module HTTP
    # Class that manages retry strategy with exponential backoff and randomization
    class RetryStrategy
      attr_reader logger: Dry::Logger::Dispatcher

      type retry_callback = ^(StandardError exception, Integer try, Float elapsed_time, Float next_interval) -> void

      type retry_options = {
        tries: Integer,
        base_interval: Float,
        multiplier: Float,
        rand_factor: Float,
        on: Array[Class],
        on_retry: retry_callback
      }

      # Initialize a new retry strategy with customizable options
      #
      # @param options [Hash] Options for retry behavior
      # @option options [Integer] :tries Number of attempts (including the initial try)
      # @option options [Float] :base_interval Initial interval between retries (seconds)
      # @option options [Float] :multiplier Exponential backoff multiplier
      # @option options [Float] :rand_factor Randomization factor
      # @option options [Array<Class>] :on Exception classes to retry on
      # @option options [Proc] :on_retry Callback called on each retry
      def initialize: (?logger: Dry::Logger::Dispatcher?, **untyped options) -> void

      # Execute the block with automatic retry on specified exceptions.
      # Uses exponential backoff with randomization for retry intervals
      #
      # @yield Block to execute
      # @return [Object] Return value of the block
      # @raise [StandardError] If the block fails after all retries
      def with_retry: [T] () { () -> T } -> T
    end
  end
end
