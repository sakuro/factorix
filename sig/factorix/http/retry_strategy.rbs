# frozen_string_literal: true

module Factorix
  module HTTP
    # Class that manages retry strategy with exponential backoff and randomization
    class RetryStrategy
      attr_reader logger: Dry::Logger::Dispatcher

      type retry_callback = ^(StandardError exception, Integer try, Float elapsed_time, Float next_interval) -> void

      type retry_options = {
        tries: Integer,
        base_interval: Float,
        multiplier: Float,
        rand_factor: Float,
        on: Array[Class],
        on_retry: retry_callback
      }

      # Initialize a new retry strategy with customizable options
      #
      # @param options [Hash] Options for retry behavior
      # @option options [Integer] :tries Number of attempts (including the initial try)
      # @option options [Float] :base_interval Initial interval between retries (seconds)
      # @option options [Float] :multiplier Exponential backoff multiplier
      # @option options [Float] :rand_factor Randomization factor
      # @option options [Array<Class>] :on Exception classes to retry on
      # @option options [Proc] :on_retry Callback called on each retry
      def initialize: (?logger: Dry::Logger::Dispatcher?, **untyped options) -> void

      # Execute the block with automatic retry on specified exceptions.
      # Uses exponential backoff with randomization for retry intervals
      #
      # @yield Block to execute
      # @return [Object] Return value of the block
      # @raise [StandardError] If the block fails after all retries
      def with_retry: [T] () { () -> T } -> T

      private

      # Configure retry options by merging with defaults and setting up callbacks
      #
      # @param options [Hash] User-provided options to merge with defaults
      # @return [Hash] Complete set of configured options
      def configure_options: (Hash[Symbol, untyped] options) -> retry_options

      # Default callback for retry attempts that logs retry information
      #
      # @param exception [StandardError] The exception that triggered the retry
      # @param try [Integer] The current retry attempt number
      # @param elapsed_time [Float] Time elapsed since first attempt
      # @param next_interval [Float] Time until next retry attempt
      # @return [void]
      def default_retry_callback: (StandardError exception, Integer try, Float elapsed_time, Float next_interval) -> void
    end
  end
end
