# frozen_string_literal: true

# RBS type signature file
# NOTE: Do not include private method definitions in RBS files.
#       Only public interfaces should be documented here.

module Factorix
  module HTTP
    # Decorator that adds retry functionality to an HTTP client
    #
    # Automatically retries transient errors (timeouts, connection issues)
    # using an exponential backoff strategy with randomization.
    class RetryDecorator
      attr_reader client: Client
      attr_reader retry_strategy: RetryStrategy
      attr_reader logger: Dry::Logger::Dispatcher

      # Execute an HTTP request with retry logic
      #
      # @param method [Symbol] HTTP method
      # @param uri [URI::HTTPS] target URI
      # @param headers [Hash<String, String>] request headers
      # @param body [String, IO, nil] request body
      # @yield [Net::HTTPResponse] for streaming responses
      # @return [Response] response object
      def request: (Symbol method, URI::HTTPS uri, ?headers: Hash[String, String], ?body: String | IO | nil) ?{ (Net::HTTPResponse) -> void } -> Response

      # Execute a GET request with retry logic
      #
      # @param uri [URI::HTTPS] target URI
      # @param headers [Hash<String, String>] request headers
      # @yield [Net::HTTPResponse] for streaming responses
      # @return [Response] response object
      def get: (URI::HTTPS uri, ?headers: Hash[String, String]) ?{ (Net::HTTPResponse) -> void } -> Response

      # Execute a POST request with retry logic
      #
      # @param uri [URI::HTTPS] target URI
      # @param body [String, IO] request body
      # @param headers [Hash<String, String>] request headers
      # @param content_type [String, nil] Content-Type header
      # @return [Response] response object
      def post: (URI::HTTPS uri, body: String | IO, ?headers: Hash[String, String], ?content_type: String?) -> Response
    end
  end
end
